DEPTH = 32768;
WIDTH = 16;
ADDRESS_RADIX = HEX;
DATA_RADIX = HEX;
CONTENT
BEGIN
	0000 : 6080;    --   [0b 0110 0000 1000 0000] -> [42: ANDI  $sp, 0]
                    --   auto-gen (0xf000 > 5bits) <- [43: ORI   $sp, 0xf000]
	0001 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	0002 : 2040;    --   [0b 0010 0000 0100 0000] -> [asm: (R2):  AND 	$at, $r0]
	0003 : 66fc;    --   [0b 0110 0110 1111 1100] -> [asm:  (I):  ORI 	$t1, 0x3c]
	0004 : 72ca;    --   [0b 0111 0010 1100 1010] -> [asm:  (I):  SLLI 	$t1, 0xa]
	0005 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	0006 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	0007 : 66c0;    --   [0b 0110 0110 1100 0000] -> [asm:  (I):  ORI 	$t1, 0x0]
	0008 : 72c6;    --   [0b 0111 0010 1100 0110] -> [asm:  (I):  SLLI 	$t1, 0x6]
	0009 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	000a : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	000b : 66c0;    --   [0b 0110 0110 1100 0000] -> [asm:  (I):  ORI 	$t1, 0x0]
	000c : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	000d : 2484;    --   [0b 0010 0100 1000 0100] -> [asm: (R2):  OR 	$sp, $at]

	000e : 60c0;    --   [0b 0110 0000 1100 0000] -> [44: ANDI  $fp, 0]
	000f : 24c8;    --   [0b 0010 0100 1100 1000] -> [45: OR    $fp, $sp]
                    --   label: 0010 <- [48: BIT_SERIAL_INPUTREADY:  .equ 1]
                    --   label: 0010 <- [49: BIT_SERIAL_OUTPUTREADY: .equ 2]
                    --   label: 0010 <- [50: REG_IOCONTOL:   .equ 0xff00]
                    --   label: 0010 <- [51: REG_IOBUFFER_1: .equ 0xff04]
                    --   label: 0010 <- [53: TEXT_AREA:        # keep current memory address before change memory address]
	7000 : 0031;    --   [0b 0000 0000 0011 0001] -> [CONST_prompt1: .asciiz "1st: ": 1]
	7001 : 0073;    --   [0b 0000 0000 0111 0011] -> [CONST_prompt1: .asciiz "1st: ": s]
	7002 : 0074;    --   [0b 0000 0000 0111 0100] -> [CONST_prompt1: .asciiz "1st: ": t]
	7003 : 003a;    --   [0b 0000 0000 0011 1010] -> [CONST_prompt1: .asciiz "1st: ": :]
	7004 : 0020;    --   [0b 0000 0000 0010 0000] -> [CONST_prompt1: .asciiz "1st: ":  ]
	7005 : 0000;    --   [0b 0000 0000 0000 0000] -> [CONST_prompt1: .asciiz "1st: ": ]
	7006 : 0032;    --   [0b 0000 0000 0011 0010] -> [CONST_prompt2: .asciiz "2nd: ": 2]
	7007 : 006e;    --   [0b 0000 0000 0110 1110] -> [CONST_prompt2: .asciiz "2nd: ": n]
	7008 : 0064;    --   [0b 0000 0000 0110 0100] -> [CONST_prompt2: .asciiz "2nd: ": d]
	7009 : 003a;    --   [0b 0000 0000 0011 1010] -> [CONST_prompt2: .asciiz "2nd: ": :]
	700a : 0020;    --   [0b 0000 0000 0010 0000] -> [CONST_prompt2: .asciiz "2nd: ":  ]
	700b : 0000;    --   [0b 0000 0000 0000 0000] -> [CONST_prompt2: .asciiz "2nd: ": ]
	700c : 0041;    --   [0b 0000 0000 0100 0001] -> [CONST_answer:  .asciiz "Ans: ": A]
	700d : 006e;    --   [0b 0000 0000 0110 1110] -> [CONST_answer:  .asciiz "Ans: ": n]
	700e : 0073;    --   [0b 0000 0000 0111 0011] -> [CONST_answer:  .asciiz "Ans: ": s]
	700f : 003a;    --   [0b 0000 0000 0011 1010] -> [CONST_answer:  .asciiz "Ans: ": :]
	7010 : 0020;    --   [0b 0000 0000 0010 0000] -> [CONST_answer:  .asciiz "Ans: ":  ]
	7011 : 0000;    --   [0b 0000 0000 0000 0000] -> [CONST_answer:  .asciiz "Ans: ": ]
                    --   auto-gen (0x520 > 10bits) <- [135: JAL   multiply_service]
	0010 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	0011 : 2040;    --   [0b 0010 0000 0100 0000] -> [asm: (R2):  AND 	$at, $r0]
	0012 : 66c1;    --   [0b 0110 0110 1100 0001] -> [asm:  (I):  ORI 	$t1, 0x1]
	0013 : 72ca;    --   [0b 0111 0010 1100 1010] -> [asm:  (I):  SLLI 	$t1, 0xa]
	0014 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	0015 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	0016 : 66c4;    --   [0b 0110 0110 1100 0100] -> [asm:  (I):  ORI 	$t1, 0x4]
	0017 : 72c6;    --   [0b 0111 0010 1100 0110] -> [asm:  (I):  SLLI 	$t1, 0x6]
	0018 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	0019 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	001a : 66e0;    --   [0b 0110 0110 1110 0000] -> [asm:  (I):  ORI 	$t1, 0x20]
	001b : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	001c : ac50;    --   [0b 1010 1100 0101 0000] -> [asm: (R2):  JALR 	$at, $ra]

                    --   auto-gen (0x616 > 10bits) <- [136: J     PROGRAM_END]
	001d : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	001e : 2040;    --   [0b 0010 0000 0100 0000] -> [asm: (R2):  AND 	$at, $r0]
	001f : 66c1;    --   [0b 0110 0110 1100 0001] -> [asm:  (I):  ORI 	$t1, 0x1]
	0020 : 72ca;    --   [0b 0111 0010 1100 1010] -> [asm:  (I):  SLLI 	$t1, 0xa]
	0021 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	0022 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	0023 : 66c8;    --   [0b 0110 0110 1100 1000] -> [asm:  (I):  ORI 	$t1, 0x8]
	0024 : 72c6;    --   [0b 0111 0010 1100 0110] -> [asm:  (I):  SLLI 	$t1, 0x6]
	0025 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	0026 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	0027 : 66d6;    --   [0b 0110 0110 1101 0110] -> [asm:  (I):  ORI 	$t1, 0x16]
	0028 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	0029 : a850;    --   [0b 1010 1000 0101 0000] -> [asm: (R1):  JR 	$at]

                    --   label: 002a <- [200: putchar: ]
	002a : 40ba;    --   [0b 0100 0000 1011 1010] -> [201: ADDI $sp, -6       # 6 byte]
	002b : c942;    --   [0b 1100 1001 0100 0010] -> [202: SW   $sp, $ra, 2]
	002c : 6040;    --   [0b 0110 0000 0100 0000] -> [203: ANDI $at, 0]
	002d : 2460;    --   [0b 0010 0100 0110 0000] -> [204: OR   $at, $s0]
	002e : c911;    --   [0b 1100 1001 0001 0001] -> [205: SW   $sp, $at, 1]
	002f : 6040;    --   [0b 0110 0000 0100 0000] -> [206: ANDI $at, 0]
	0030 : 2464;    --   [0b 0010 0100 0110 0100] -> [207: OR   $at, $s1]
	0031 : c910;    --   [0b 1100 1001 0001 0000] -> [208: SW   $sp, $at, 0]
	0032 : 6100;    --   [0b 0110 0001 0000 0000] -> [210: ANDI $ra, 0        # $ra = 0]
	0033 : 6140;    --   [0b 0110 0001 0100 0000] -> [211: ANDI $rb, 0        # $rb = 0]
	0034 : 6180;    --   [0b 0110 0001 1000 0000] -> [212: ANDI $rc, 0        # $rc = 0]
	0035 : 61c0;    --   [0b 0110 0001 1100 0000] -> [213: ANDI $rd, 0        # $rd = 0]
	0036 : 6502;    --   [0b 0110 0101 0000 0010] -> [215: ORI  $ra, BIT_SERIAL_OUTPUTREADY]
                    --   auto-gen (0xff00 > 5bits) <- [216: ORI  $rb, REG_IOCONTOL     ]
	0037 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	0038 : 2040;    --   [0b 0010 0000 0100 0000] -> [asm: (R2):  AND 	$at, $r0]
	0039 : 66ff;    --   [0b 0110 0110 1111 1111] -> [asm:  (I):  ORI 	$t1, 0x3f]
	003a : 72ca;    --   [0b 0111 0010 1100 1010] -> [asm:  (I):  SLLI 	$t1, 0xa]
	003b : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	003c : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	003d : 66cc;    --   [0b 0110 0110 1100 1100] -> [asm:  (I):  ORI 	$t1, 0xc]
	003e : 72c6;    --   [0b 0111 0010 1100 0110] -> [asm:  (I):  SLLI 	$t1, 0x6]
	003f : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	0040 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	0041 : 66c0;    --   [0b 0110 0110 1100 0000] -> [asm:  (I):  ORI 	$t1, 0x0]
	0042 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	0043 : 2544;    --   [0b 0010 0101 0100 0100] -> [asm: (R2):  OR 	$rb, $at]

                    --   auto-gen (0xff04 > 5bits) <- [217: ORI  $rc, REG_IOBUFFER_1   ]
	0044 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	0045 : 2040;    --   [0b 0010 0000 0100 0000] -> [asm: (R2):  AND 	$at, $r0]
	0046 : 66ff;    --   [0b 0110 0110 1111 1111] -> [asm:  (I):  ORI 	$t1, 0x3f]
	0047 : 72ca;    --   [0b 0111 0010 1100 1010] -> [asm:  (I):  SLLI 	$t1, 0xa]
	0048 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	0049 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	004a : 66cc;    --   [0b 0110 0110 1100 1100] -> [asm:  (I):  ORI 	$t1, 0xc]
	004b : 72c6;    --   [0b 0111 0010 1100 0110] -> [asm:  (I):  SLLI 	$t1, 0x6]
	004c : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	004d : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	004e : 66c4;    --   [0b 0110 0110 1100 0100] -> [asm:  (I):  ORI 	$t1, 0x4]
	004f : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	0050 : 2584;    --   [0b 0010 0101 1000 0100] -> [asm: (R2):  OR 	$rc, $at]

	0051 : 25e8;    --   [0b 0010 0101 1110 1000] -> [218: OR   $rd, $t0      # $rd = character]
	0052 : c4d0;    --   [0b 1100 0100 1101 0000] -> [220: LB   $at, $rb, 0   # $at = $($rb)]
	0053 : 2050;    --   [0b 0010 0000 0101 0000] -> [221: AND  $at, $ra      # $at & ra to check if ready to write]
	0054 : b4ce;    --   [0b 1011 0100 1100 1110] -> [222: BNE  $at, $ra, -2  # go back -2 words if $at != $ra]
	0055 : cf70;    --   [0b 1100 1111 0111 0000] -> [223: SB   $rc, $rd, 0   # $($rc + 0) = $rd for one byte]
	0056 : c0a0;    --   [0b 1100 0000 1010 0000] -> [225: LW   $at, $sp, 0]
	0057 : 6240;    --   [0b 0110 0010 0100 0000] -> [226: ANDI $s1, 0]
	0058 : 2644;    --   [0b 0010 0110 0100 0100] -> [227: OR   $s1, $at]
	0059 : c0a1;    --   [0b 1100 0000 1010 0001] -> [228: LW   $at, $sp, 1]
	005a : 6200;    --   [0b 0110 0010 0000 0000] -> [229: ANDI $s0, 0]
	005b : 2604;    --   [0b 0010 0110 0000 0100] -> [230: OR   $s0, $at]
	005c : c222;    --   [0b 1100 0010 0010 0010] -> [231: LW   $ra, $sp, 2   # restore $ra and return]
	005d : 4086;    --   [0b 0100 0000 1000 0110] -> [232: ADDI $sp, 6]
	005e : a900;    --   [0b 1010 1001 0000 0000] -> [233: JR   $ra]
                    --   label: 005f <- [244: getchar:]
	005f : 40bc;    --   [0b 0100 0000 1011 1100] -> [245: ADDI $sp, -4       # 4 byte]
	0060 : c941;    --   [0b 1100 1001 0100 0001] -> [246: SW   $sp, $ra, 1]
	0061 : 6040;    --   [0b 0110 0000 0100 0000] -> [247: ANDI $at, 0]
	0062 : 2460;    --   [0b 0010 0100 0110 0000] -> [248: OR   $at, $s0]
	0063 : c910;    --   [0b 1100 1001 0001 0000] -> [249: SW   $sp, $at, 0]
	0064 : 6100;    --   [0b 0110 0001 0000 0000] -> [251: ANDI $ra, 0        # $ra = 0]
	0065 : 6140;    --   [0b 0110 0001 0100 0000] -> [252: ANDI $rb, 0        # $rb = 0]
	0066 : 6180;    --   [0b 0110 0001 1000 0000] -> [253: ANDI $rc, 0        # $rc = 0]
	0067 : 61c0;    --   [0b 0110 0001 1100 0000] -> [254: ANDI $rd, 0        # $rd = 0]
	0068 : 6501;    --   [0b 0110 0101 0000 0001] -> [256: ORI  $ra, BIT_SERIAL_INPUTREADY ]
                    --   auto-gen (0xff00 > 5bits) <- [257: ORI  $rb, REG_IOCONTOL     	]
	0069 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	006a : 2040;    --   [0b 0010 0000 0100 0000] -> [asm: (R2):  AND 	$at, $r0]
	006b : 66ff;    --   [0b 0110 0110 1111 1111] -> [asm:  (I):  ORI 	$t1, 0x3f]
	006c : 72ca;    --   [0b 0111 0010 1100 1010] -> [asm:  (I):  SLLI 	$t1, 0xa]
	006d : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	006e : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	006f : 66cc;    --   [0b 0110 0110 1100 1100] -> [asm:  (I):  ORI 	$t1, 0xc]
	0070 : 72c6;    --   [0b 0111 0010 1100 0110] -> [asm:  (I):  SLLI 	$t1, 0x6]
	0071 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	0072 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	0073 : 66c0;    --   [0b 0110 0110 1100 0000] -> [asm:  (I):  ORI 	$t1, 0x0]
	0074 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	0075 : 2544;    --   [0b 0010 0101 0100 0100] -> [asm: (R2):  OR 	$rb, $at]

                    --   auto-gen (0xff04 > 5bits) <- [258: ORI  $rc, REG_IOBUFFER_1   	]
	0076 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	0077 : 2040;    --   [0b 0010 0000 0100 0000] -> [asm: (R2):  AND 	$at, $r0]
	0078 : 66ff;    --   [0b 0110 0110 1111 1111] -> [asm:  (I):  ORI 	$t1, 0x3f]
	0079 : 72ca;    --   [0b 0111 0010 1100 1010] -> [asm:  (I):  SLLI 	$t1, 0xa]
	007a : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	007b : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	007c : 66cc;    --   [0b 0110 0110 1100 1100] -> [asm:  (I):  ORI 	$t1, 0xc]
	007d : 72c6;    --   [0b 0111 0010 1100 0110] -> [asm:  (I):  SLLI 	$t1, 0x6]
	007e : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	007f : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	0080 : 66c4;    --   [0b 0110 0110 1100 0100] -> [asm:  (I):  ORI 	$t1, 0x4]
	0081 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	0082 : 2584;    --   [0b 0010 0101 1000 0100] -> [asm: (R2):  OR 	$rc, $at]

	0083 : c4d0;    --   [0b 1100 0100 1101 0000] -> [260: LB   $at, $rb, 0   # $at = $($rb)]
	0084 : 2050;    --   [0b 0010 0000 0101 0000] -> [261: AND  $at, $ra      # $at & ra to check if ready to write]
	0085 : b4ce;    --   [0b 1011 0100 1100 1110] -> [262: BNE  $at, $ra, -2  # go back -2 words if $at != $ra]
	0086 : c7e0;    --   [0b 1100 0111 1110 0000] -> [263: LB   $rd, $rc, 0   # $rd = $($rc + 0) for one character byte]
	0087 : 6280;    --   [0b 0110 0010 1000 0000] -> [264: ANDI $t0, 0]
	0088 : 269c;    --   [0b 0010 0110 1001 1100] -> [265: OR   $t0, $rd      # store char to return register]
	0089 : c0a0;    --   [0b 1100 0000 1010 0000] -> [267: LW   $at, $sp, 0]
	008a : 6200;    --   [0b 0110 0010 0000 0000] -> [268: ANDI $s0, 0]
	008b : 2604;    --   [0b 0010 0110 0000 0100] -> [269: OR   $s0, $at]
	008c : c221;    --   [0b 1100 0010 0010 0001] -> [270: LW   $ra, $sp, 1   # restore $ra and return]
	008d : 4084;    --   [0b 0100 0000 1000 0100] -> [271: ADDI $sp, 4]
	008e : a900;    --   [0b 1010 1001 0000 0000] -> [272: JR   $ra]
                    --   label: 008f <- [282: putString:]
	008f : 40bc;    --   [0b 0100 0000 1011 1100] -> [283: ADDI $sp, -4       # 4 byte]
	0090 : c941;    --   [0b 1100 1001 0100 0001] -> [284: SW   $sp, $ra, 1]
	0091 : 6040;    --   [0b 0110 0000 0100 0000] -> [285: ANDI $at, 0]
	0092 : 2460;    --   [0b 0010 0100 0110 0000] -> [286: OR   $at, $s0]
	0093 : c910;    --   [0b 1100 1001 0001 0000] -> [287: SW   $sp, $at, 0]
	0094 : 6200;    --   [0b 0110 0010 0000 0000] -> [289: ANDI $s0, 0        # $s0 = 0]
	0095 : 2628;    --   [0b 0010 0110 0010 1000] -> [290: OR   $s0, $t0      # string counter]
                    --   label: 0096 <- [292: putcharloop:]
	0096 : 6040;    --   [0b 0110 0000 0100 0000] -> [293: ANDI $at, 0]
	0097 : 2460;    --   [0b 0010 0100 0110 0000] -> [294: OR   $at, $s0      # prepare for load]
	0098 : 61c0;    --   [0b 0110 0001 1100 0000] -> [295: ANDI $rd, 0        # $rd = 0]
	0099 : c790;    --   [0b 1100 0111 1001 0000] -> [296: LB   $rd, $at, 0   # prepare a byte from in-memory]
	009a : 6280;    --   [0b 0110 0010 1000 0000] -> [297: ANDI $t0, 0]
	009b : 269c;    --   [0b 0010 0110 1001 1100] -> [298: OR   $t0, $rd      # set argument]
	009c : b386;    --   [0b 1011 0011 1000 0110] -> [299: BEQ  $rd, $r0, 6   # branch if null character read]
	009d : a454;    --   [0b 1010 0100 0101 0100] -> [300: JAL  putchar]
	009e : 4202;    --   [0b 0100 0010 0000 0010] -> [302: ADDI $s0, 2        # next char]
	009f : a12c;    --   [0b 1010 0001 0010 1100] -> [303: J    putcharloop   # load again]
	00a0 : 6280;    --   [0b 0110 0010 1000 0000] -> [304: ANDI $t0, 0        # put null char at the end]
	00a1 : a454;    --   [0b 1010 0100 0101 0100] -> [305: JAL  putchar]
	00a2 : c0a0;    --   [0b 1100 0000 1010 0000] -> [307: LW   $at, $sp, 0]
	00a3 : 6200;    --   [0b 0110 0010 0000 0000] -> [308: ANDI $s0, 0]
	00a4 : 2604;    --   [0b 0010 0110 0000 0100] -> [309: OR   $s0, $at]
	00a5 : c221;    --   [0b 1100 0010 0010 0001] -> [310: LW   $ra, $sp, 1   # restore $ra and return]
	00a6 : 4084;    --   [0b 0100 0000 1000 0100] -> [311: ADDI $sp, 4]
	00a7 : a900;    --   [0b 1010 1001 0000 0000] -> [312: JR   $ra]
                    --   label: 00a8 <- [324: getString:]
	00a8 : 40bc;    --   [0b 0100 0000 1011 1100] -> [325: ADDI $sp, -4       # 4 byte]
	00a9 : c941;    --   [0b 1100 1001 0100 0001] -> [326: SW   $sp, $ra, 1]
	00aa : 6040;    --   [0b 0110 0000 0100 0000] -> [327: ANDI $at, 0]
	00ab : 2460;    --   [0b 0010 0100 0110 0000] -> [328: OR   $at, $s0]
	00ac : c910;    --   [0b 1100 1001 0001 0000] -> [329: SW   $sp, $at, 0]
	00ad : 6100;    --   [0b 0110 0001 0000 0000] -> [331: ANDI $ra, 0]
	00ae : 6501;    --   [0b 0110 0101 0000 0001] -> [332: ORI  $ra, BIT_SERIAL_INPUTREADY]
	00af : 6140;    --   [0b 0110 0001 0100 0000] -> [333: ANDI $rb, 0]
                    --   auto-gen (0xff00 > 5bits) <- [334: ORI  $rb, REG_IOCONTOL]
	00b0 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	00b1 : 2040;    --   [0b 0010 0000 0100 0000] -> [asm: (R2):  AND 	$at, $r0]
	00b2 : 66ff;    --   [0b 0110 0110 1111 1111] -> [asm:  (I):  ORI 	$t1, 0x3f]
	00b3 : 72ca;    --   [0b 0111 0010 1100 1010] -> [asm:  (I):  SLLI 	$t1, 0xa]
	00b4 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	00b5 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	00b6 : 66cc;    --   [0b 0110 0110 1100 1100] -> [asm:  (I):  ORI 	$t1, 0xc]
	00b7 : 72c6;    --   [0b 0111 0010 1100 0110] -> [asm:  (I):  SLLI 	$t1, 0x6]
	00b8 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	00b9 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	00ba : 66c0;    --   [0b 0110 0110 1100 0000] -> [asm:  (I):  ORI 	$t1, 0x0]
	00bb : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	00bc : 2544;    --   [0b 0010 0101 0100 0100] -> [asm: (R2):  OR 	$rb, $at]

	00bd : cec0;    --   [0b 1100 1110 1100 0000] -> [335: SB   $rb, $ra, 0   # Flush the serial port input queue to get ready for input]
	00be : 6200;    --   [0b 0110 0010 0000 0000] -> [337: ANDI $s0, 0        # $s0 = 0]
	00bf : 2628;    --   [0b 0010 0110 0010 1000] -> [338: OR   $s0, $t0      # $s0 is address of char for string]
                    --   label: 00c0 <- [340: getcharloop:]
	00c0 : a4be;    --   [0b 1010 0100 1011 1110] -> [341: JAL  getchar]
	00c1 : 61c0;    --   [0b 0110 0001 1100 0000] -> [342: ANDI $rd, 0]
	00c2 : 25e8;    --   [0b 0010 0101 1110 1000] -> [343: OR   $rd, $t0      # copy getchar result $t0]
	00c3 : 6180;    --   [0b 0110 0001 1000 0000] -> [344: ANDI $rc, 0]
	00c4 : 25a0;    --   [0b 0010 0101 1010 0000] -> [345: OR   $rc, $s0      ]
	00c5 : cf70;    --   [0b 1100 1111 0111 0000] -> [346: SB   $rc, $rd, 0   # store one byte in $rd]
	00c6 : 4202;    --   [0b 0100 0010 0000 0010] -> [348: ADDI $s0, 2        # next char is 2 bytes away, because only lower word is used]
	00c7 : 6040;    --   [0b 0110 0000 0100 0000] -> [349: ANDI $at, 0]
	00c8 : 644a;    --   [0b 0110 0100 0100 1010] -> [350: ORI  $at, '\n']
	00c9 : b392;    --   [0b 1011 0011 1001 0010] -> [351: BEQ  $rd, $at, 2   # branch if '\n' character read]
	00ca : a180;    --   [0b 1010 0001 1000 0000] -> [352: J    getcharloop   # read again]
	00cb : 6180;    --   [0b 0110 0001 1000 0000] -> [353: ANDI $rc, 0]
	00cc : 25a0;    --   [0b 0010 0101 1010 0000] -> [354: OR   $rc, $s0      ]
	00cd : cf00;    --   [0b 1100 1111 0000 0000] -> [355: SB   $rc, $r0, 0   # put null char to terminate]
	00ce : 6100;    --   [0b 0110 0001 0000 0000] -> [357: ANDI $ra, 0]
	00cf : 6501;    --   [0b 0110 0101 0000 0001] -> [358: ORI  $ra, BIT_SERIAL_INPUTREADY]
	00d0 : 6502;    --   [0b 0110 0101 0000 0010] -> [359: ORI  $ra, BIT_SERIAL_OUTPUTREADY]
	00d1 : 6140;    --   [0b 0110 0001 0100 0000] -> [360: ANDI $rb, 0]
                    --   auto-gen (0xff00 > 5bits) <- [361: ORI  $rb, REG_IOCONTOL]
	00d2 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	00d3 : 2040;    --   [0b 0010 0000 0100 0000] -> [asm: (R2):  AND 	$at, $r0]
	00d4 : 66ff;    --   [0b 0110 0110 1111 1111] -> [asm:  (I):  ORI 	$t1, 0x3f]
	00d5 : 72ca;    --   [0b 0111 0010 1100 1010] -> [asm:  (I):  SLLI 	$t1, 0xa]
	00d6 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	00d7 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	00d8 : 66cc;    --   [0b 0110 0110 1100 1100] -> [asm:  (I):  ORI 	$t1, 0xc]
	00d9 : 72c6;    --   [0b 0111 0010 1100 0110] -> [asm:  (I):  SLLI 	$t1, 0x6]
	00da : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	00db : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	00dc : 66c0;    --   [0b 0110 0110 1100 0000] -> [asm:  (I):  ORI 	$t1, 0x0]
	00dd : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	00de : 2544;    --   [0b 0010 0101 0100 0100] -> [asm: (R2):  OR 	$rb, $at]

	00df : cec0;    --   [0b 1100 1110 1100 0000] -> [362: SB   $rb, $ra, 0   # Flush the serial port input queue to get ready for input]
	00e0 : c0a0;    --   [0b 1100 0000 1010 0000] -> [364: LW   $at, $sp, 0]
	00e1 : 6200;    --   [0b 0110 0010 0000 0000] -> [365: ANDI $s0, 0]
	00e2 : 2604;    --   [0b 0010 0110 0000 0100] -> [366: OR   $s0, $at]
	00e3 : c221;    --   [0b 1100 0010 0010 0001] -> [367: LW   $ra, $sp, 1   # restore $ra and return]
	00e4 : 4084;    --   [0b 0100 0000 1000 0100] -> [368: ADDI $sp, 4]
	00e5 : a900;    --   [0b 1010 1001 0000 0000] -> [369: JR   $ra]
                    --   label: 00e6 <- [383: intToString:]
	00e6 : 40be;    --   [0b 0100 0000 1011 1110] -> [384: ADDI  $sp, -2]
	00e7 : c940;    --   [0b 1100 1001 0100 0000] -> [385: SW    $sp, $ra, 0   # save return address ]
	00e8 : 6140;    --   [0b 0110 0001 0100 0000] -> [387: ANDI  $rb, 0       # $rb is output value]
	00e9 : 6200;    --   [0b 0110 0010 0000 0000] -> [388: ANDI  $s0, 0       # $s0 is data to be processed]
	00ea : 2628;    --   [0b 0010 0110 0010 1000] -> [389: OR    $s0, $t0]
	00eb : 6240;    --   [0b 0110 0010 0100 0000] -> [390: ANDI  $s1, 0       # $s1 is FSM to keep number char is seen]
	00ec : 6100;    --   [0b 0110 0001 0000 0000] -> [393: ANDI  $ra, 0]
	00ed : 2520;    --   [0b 0010 0101 0010 0000] -> [394: OR    $ra, $s0]
                    --   auto-gen (0x8000 > 5bits) <- [395: ANDI  $ra, 0x8000   # check if negative]
	00ee : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	00ef : 2040;    --   [0b 0010 0000 0100 0000] -> [asm: (R2):  AND 	$at, $r0]
	00f0 : 66e0;    --   [0b 0110 0110 1110 0000] -> [asm:  (I):  ORI 	$t1, 0x20]
	00f1 : 72ca;    --   [0b 0111 0010 1100 1010] -> [asm:  (I):  SLLI 	$t1, 0xa]
	00f2 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	00f3 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	00f4 : 66c0;    --   [0b 0110 0110 1100 0000] -> [asm:  (I):  ORI 	$t1, 0x0]
	00f5 : 72c6;    --   [0b 0111 0010 1100 0110] -> [asm:  (I):  SLLI 	$t1, 0x6]
	00f6 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	00f7 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	00f8 : 66c0;    --   [0b 0110 0110 1100 0000] -> [asm:  (I):  ORI 	$t1, 0x0]
	00f9 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	00fa : 2104;    --   [0b 0010 0001 0000 0100] -> [asm: (R2):  AND 	$ra, $at]

	00fb : b602;    --   [0b 1011 0110 0000 0010] -> [396: BNE   $ra, $r0, 2   # go to negative process]
	00fc : a274;    --   [0b 1010 0010 0111 0100] -> [397: J     digit5]
                    --   auto-gen (0xffff > 5bits) <- [399: XORI  $s0, 0xffff   # flip bits]
	00fd : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	00fe : 2040;    --   [0b 0010 0000 0100 0000] -> [asm: (R2):  AND 	$at, $r0]
	00ff : 66ff;    --   [0b 0110 0110 1111 1111] -> [asm:  (I):  ORI 	$t1, 0x3f]
	0100 : 72ca;    --   [0b 0111 0010 1100 1010] -> [asm:  (I):  SLLI 	$t1, 0xa]
	0101 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	0102 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	0103 : 66cf;    --   [0b 0110 0110 1100 1111] -> [asm:  (I):  ORI 	$t1, 0xf]
	0104 : 72c6;    --   [0b 0111 0010 1100 0110] -> [asm:  (I):  SLLI 	$t1, 0x6]
	0105 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	0106 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	0107 : 66ff;    --   [0b 0110 0110 1111 1111] -> [asm:  (I):  ORI 	$t1, 0x3f]
	0108 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	0109 : 2a04;    --   [0b 0010 1010 0000 0100] -> [asm: (R2):  XOR 	$s0, $at]

	010a : 4201;    --   [0b 0100 0010 0000 0001] -> [400: ADDI  $s0, 1        # +1 to negate initial data]
	010b : 6280;    --   [0b 0110 0010 1000 0000] -> [401: ANDI  $t0, 0]
	010c : 66ad;    --   [0b 0110 0110 1010 1101] -> [402: ORI   $t0, '-'      # set argument for putchar]
	010d : a454;    --   [0b 1010 0100 0101 0100] -> [403: JAL   putchar       # put '-']
	010e : a274;    --   [0b 1010 0010 0111 0100] -> [404: J     digit5        # start looping for digit counts]
                    --   label: 010f <- [406: digitloop:          # process $rb = $s0/$rc, $s0 = $s0 % $rc]
	010f : 6040;    --   [0b 0110 0000 0100 0000] -> [407: ANDI  $at, 0    ]
	0110 : 2460;    --   [0b 0010 0100 0110 0000] -> [408: OR    $at, $s0      # $at is copy of $s0 to test]
	0111 : 0458;    --   [0b 0000 0100 0101 1000] -> [409: SUB   $at, $rc]
	0112 : 0c40;    --   [0b 0000 1100 0100 0000] -> [410: SLT   $at, $r0      # test if data < divisor]
	0113 : b484;    --   [0b 1011 0100 1000 0100] -> [411: BNE   $at, $r0, 4   # go to next if data < divisor]
	0114 : 0618;    --   [0b 0000 0110 0001 1000] -> [412: SUB   $s0, $rc]
	0115 : 4141;    --   [0b 0100 0001 0100 0001] -> [413: ADDI  $rb, 1]
	0116 : a21e;    --   [0b 1010 0010 0001 1110] -> [414: J     digitloop]
                    --   label: 0117 <- [416: int_to_char:        # putchar($rb + '0') ]
                    --   auto-gen (0x30 > 5bits) <- [417: ADDI  $rb, '0']
	0117 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	0118 : 2040;    --   [0b 0010 0000 0100 0000] -> [asm: (R2):  AND 	$at, $r0]
	0119 : 66c0;    --   [0b 0110 0110 1100 0000] -> [asm:  (I):  ORI 	$t1, 0x0]
	011a : 72ca;    --   [0b 0111 0010 1100 1010] -> [asm:  (I):  SLLI 	$t1, 0xa]
	011b : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	011c : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	011d : 66c0;    --   [0b 0110 0110 1100 0000] -> [asm:  (I):  ORI 	$t1, 0x0]
	011e : 72c6;    --   [0b 0111 0010 1100 0110] -> [asm:  (I):  SLLI 	$t1, 0x6]
	011f : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	0120 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	0121 : 66f0;    --   [0b 0110 0110 1111 0000] -> [asm:  (I):  ORI 	$t1, 0x30]
	0122 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	0123 : 0144;    --   [0b 0000 0001 0100 0100] -> [asm: (R2):  ADD 	$rb, $at]

	0124 : 6280;    --   [0b 0110 0010 1000 0000] -> [418: ANDI  $t0, 0]
	0125 : 2694;    --   [0b 0010 0110 1001 0100] -> [419: OR    $t0, $rb]
	0126 : 6140;    --   [0b 0110 0001 0100 0000] -> [420: ANDI  $rb, 0        # reset to zero ]
	0127 : 6641;    --   [0b 0110 0110 0100 0001] -> [421: ORI   $s1, 1        # FSM to keep char is written]
	0128 : 40be;    --   [0b 0100 0000 1011 1110] -> [422: ADDI  $sp, -2       # store current $ra to $sp before JAL]
	0129 : c940;    --   [0b 1100 1001 0100 0000] -> [423: SW    $sp, $ra, 0]
	012a : a454;    --   [0b 1010 0100 0101 0100] -> [424: JAL   putchar]
	012b : c220;    --   [0b 1100 0010 0010 0000] -> [425: LW    $ra, $sp, 0]
	012c : 4082;    --   [0b 0100 0000 1000 0010] -> [426: ADDI  $sp, 2]
	012d : a900;    --   [0b 1010 1001 0000 0000] -> [427: JR    $ra]
                    --   label: 012e <- [429: zeroHandler:       # put '0' when $s1 is zero]
	012e : 6040;    --   [0b 0110 0000 0100 0000] -> [430: ANDI  $at, 0]
	012f : 2464;    --   [0b 0010 0100 0110 0100] -> [431: OR    $at, $s1]
	0130 : b482;    --   [0b 1011 0100 1000 0010] -> [432: BNE   $at, $r0, 2  # BNE 0 means $s1 = 1 where number char is seen, so need to put '0']
	0131 : a900;    --   [0b 1010 1001 0000 0000] -> [433: JR    $ra]
	0132 : 6280;    --   [0b 0110 0010 1000 0000] -> [434: ANDI  $t0, 0]
	0133 : 66b0;    --   [0b 0110 0110 1011 0000] -> [435: ORI   $t0, '0']
	0134 : 40be;    --   [0b 0100 0000 1011 1110] -> [436: ADDI  $sp, -2      # store current $ra to $sp before JAL]
	0135 : c940;    --   [0b 1100 1001 0100 0000] -> [437: SW    $sp, $ra, 0]
	0136 : a454;    --   [0b 1010 0100 0101 0100] -> [438: JAL   putchar]
	0137 : c220;    --   [0b 1100 0010 0010 0000] -> [439: LW    $ra, $sp, 0]
	0138 : 4082;    --   [0b 0100 0000 1000 0010] -> [440: ADDI  $sp, 2]
	0139 : a900;    --   [0b 1010 1001 0000 0000] -> [441: JR    $ra]
                    --   label: 013a <- [443: digit5:]
	013a : 6180;    --   [0b 0110 0001 1000 0000] -> [444: ANDI  $rc, 0]
                    --   auto-gen (0x2710 > 5bits) <- [445: ORI   $rc, 10000   # $rc is divisor]
	013b : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	013c : 2040;    --   [0b 0010 0000 0100 0000] -> [asm: (R2):  AND 	$at, $r0]
	013d : 66c9;    --   [0b 0110 0110 1100 1001] -> [asm:  (I):  ORI 	$t1, 0x9]
	013e : 72ca;    --   [0b 0111 0010 1100 1010] -> [asm:  (I):  SLLI 	$t1, 0xa]
	013f : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	0140 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	0141 : 66cc;    --   [0b 0110 0110 1100 1100] -> [asm:  (I):  ORI 	$t1, 0xc]
	0142 : 72c6;    --   [0b 0111 0010 1100 0110] -> [asm:  (I):  SLLI 	$t1, 0x6]
	0143 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	0144 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	0145 : 66d0;    --   [0b 0110 0110 1101 0000] -> [asm:  (I):  ORI 	$t1, 0x10]
	0146 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	0147 : 2584;    --   [0b 0010 0101 1000 0100] -> [asm: (R2):  OR 	$rc, $at]

	0148 : 6040;    --   [0b 0110 0000 0100 0000] -> [446: ANDI  $at, 0]
	0149 : 2460;    --   [0b 0010 0100 0110 0000] -> [447: OR    $at, $s0]
	014a : 0c58;    --   [0b 0000 1100 0101 1000] -> [448: SLT   $at, $rc     # compare $s0 and divisor]
	014b : b483;    --   [0b 1011 0100 1000 0011] -> [449: BNE   $at, $r0, 3  # BNE means branch if $s0 < 10000]
	014c : a61e;    --   [0b 1010 0110 0001 1110] -> [450: JAL   digitloop]
	014d : a29e;    --   [0b 1010 0010 1001 1110] -> [451: J     digit4]
	014e : a65c;    --   [0b 1010 0110 0101 1100] -> [452: JAL   zeroHandler]
                    --   label: 014f <- [454: digit4:]
	014f : 6180;    --   [0b 0110 0001 1000 0000] -> [455: ANDI  $rc, 0]
                    --   auto-gen (0x3e8 > 5bits) <- [456: ORI   $rc, 1000]
	0150 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	0151 : 2040;    --   [0b 0010 0000 0100 0000] -> [asm: (R2):  AND 	$at, $r0]
	0152 : 66c0;    --   [0b 0110 0110 1100 0000] -> [asm:  (I):  ORI 	$t1, 0x0]
	0153 : 72ca;    --   [0b 0111 0010 1100 1010] -> [asm:  (I):  SLLI 	$t1, 0xa]
	0154 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	0155 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	0156 : 66cf;    --   [0b 0110 0110 1100 1111] -> [asm:  (I):  ORI 	$t1, 0xf]
	0157 : 72c6;    --   [0b 0111 0010 1100 0110] -> [asm:  (I):  SLLI 	$t1, 0x6]
	0158 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	0159 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	015a : 66e8;    --   [0b 0110 0110 1110 1000] -> [asm:  (I):  ORI 	$t1, 0x28]
	015b : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	015c : 2584;    --   [0b 0010 0101 1000 0100] -> [asm: (R2):  OR 	$rc, $at]

	015d : 6040;    --   [0b 0110 0000 0100 0000] -> [457: ANDI  $at, 0]
	015e : 2460;    --   [0b 0010 0100 0110 0000] -> [458: OR    $at, $s0]
	015f : 0c58;    --   [0b 0000 1100 0101 1000] -> [459: SLT   $at, $rc     # compare $s0 and divisor]
	0160 : b483;    --   [0b 1011 0100 1000 0011] -> [460: BNE   $at, $r0, 3  # BNE means branch if $s0 < 1000]
	0161 : a61e;    --   [0b 1010 0110 0001 1110] -> [461: JAL   digitloop]
	0162 : a2c8;    --   [0b 1010 0010 1100 1000] -> [462: J     digit3]
	0163 : a65c;    --   [0b 1010 0110 0101 1100] -> [463: JAL   zeroHandler]
                    --   label: 0164 <- [465: digit3:]
	0164 : 6180;    --   [0b 0110 0001 1000 0000] -> [466: ANDI  $rc, 0]
                    --   auto-gen (0x64 > 5bits) <- [467: ORI   $rc, 100]
	0165 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	0166 : 2040;    --   [0b 0010 0000 0100 0000] -> [asm: (R2):  AND 	$at, $r0]
	0167 : 66c0;    --   [0b 0110 0110 1100 0000] -> [asm:  (I):  ORI 	$t1, 0x0]
	0168 : 72ca;    --   [0b 0111 0010 1100 1010] -> [asm:  (I):  SLLI 	$t1, 0xa]
	0169 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	016a : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	016b : 66c1;    --   [0b 0110 0110 1100 0001] -> [asm:  (I):  ORI 	$t1, 0x1]
	016c : 72c6;    --   [0b 0111 0010 1100 0110] -> [asm:  (I):  SLLI 	$t1, 0x6]
	016d : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	016e : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	016f : 66e4;    --   [0b 0110 0110 1110 0100] -> [asm:  (I):  ORI 	$t1, 0x24]
	0170 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	0171 : 2584;    --   [0b 0010 0101 1000 0100] -> [asm: (R2):  OR 	$rc, $at]

	0172 : 6040;    --   [0b 0110 0000 0100 0000] -> [468: ANDI  $at, 0]
	0173 : 2460;    --   [0b 0010 0100 0110 0000] -> [469: OR    $at, $s0]
	0174 : 0c58;    --   [0b 0000 1100 0101 1000] -> [470: SLT   $at, $rc     # compare $s0 and divisor]
	0175 : b483;    --   [0b 1011 0100 1000 0011] -> [471: BNE   $at, $r0, 3  # BNE means branch if $s0 < 100]
	0176 : a61e;    --   [0b 1010 0110 0001 1110] -> [472: JAL   digitloop]
	0177 : a2f2;    --   [0b 1010 0010 1111 0010] -> [473: J     digit2]
	0178 : a65c;    --   [0b 1010 0110 0101 1100] -> [474: JAL   zeroHandler]
                    --   label: 0179 <- [476: digit2:]
	0179 : 6180;    --   [0b 0110 0001 1000 0000] -> [477: ANDI  $rc, 0]
	017a : 658a;    --   [0b 0110 0101 1000 1010] -> [478: ORI   $rc, 10]
	017b : 6040;    --   [0b 0110 0000 0100 0000] -> [479: ANDI  $at, 0]
	017c : 2460;    --   [0b 0010 0100 0110 0000] -> [480: OR    $at, $s0]
	017d : 0c58;    --   [0b 0000 1100 0101 1000] -> [481: SLT   $at, $rc     # compare $s0 and divisor]
	017e : b483;    --   [0b 1011 0100 1000 0011] -> [482: BNE   $at, $r0, 3  # BNE means branch if $s0 < 10]
	017f : a61e;    --   [0b 1010 0110 0001 1110] -> [483: JAL   digitloop]
	0180 : a304;    --   [0b 1010 0011 0000 0100] -> [484: J     digit1]
	0181 : a65c;    --   [0b 1010 0110 0101 1100] -> [485: JAL   zeroHandler]
                    --   label: 0182 <- [487: digit1:]
	0182 : 6140;    --   [0b 0110 0001 0100 0000] -> [488: ANDI  $rb, 0       # copy the rest of number $s0 to $rb ]
	0183 : 2560;    --   [0b 0010 0101 0110 0000] -> [489: OR    $rb, $s0     # int_to_char takes $rb to put number char]
	0184 : a62e;    --   [0b 1010 0110 0010 1110] -> [490: JAL   int_to_char]
	0185 : c220;    --   [0b 1100 0010 0010 0000] -> [492: LW   $ra, $sp, 0   # restore $ra]
	0186 : 4082;    --   [0b 0100 0000 1000 0010] -> [493: ADDI $sp, 2        # restore $sp and return]
	0187 : a900;    --   [0b 1010 1001 0000 0000] -> [494: JR   $ra]
                    --   label: 0188 <- [507: stringToInt:]
	0188 : 40bc;    --   [0b 0100 0000 1011 1100] -> [508: ADDI  $sp, -4       # 4 byte]
	0189 : c941;    --   [0b 1100 1001 0100 0001] -> [509: SW    $sp, $ra, 1   # save return address]
	018a : 6040;    --   [0b 0110 0000 0100 0000] -> [510: ANDI  $at, 0        # move $s0 to $at because SW is O_TYPE that]
	018b : 2460;    --   [0b 0010 0100 0110 0000] -> [511: OR    $at, $s0      # accepts registers r0|at|sp|fp|ra|rb|rc|rd]
	018c : c910;    --   [0b 1100 1001 0001 0000] -> [512: SW    $sp, $at, 0   # saved register $s0 will be used]
	018d : 6200;    --   [0b 0110 0010 0000 0000] -> [514: ANDI  $s0, 0        # FSM to check if '-' is seen]
	018e : 6180;    --   [0b 0110 0001 1000 0000] -> [515: ANDI  $rc, 0        # keeps integer]
	018f : 61c0;    --   [0b 0110 0001 1100 0000] -> [516: ANDI  $rd, 0        # $rd keeps char from getString]
                    --   label: 0190 <- [518: check_negative:]
	0190 : 6140;    --   [0b 0110 0001 0100 0000] -> [519: ANDI  $rb, 0]
                    --   auto-gen (0x360 > 5bits) <- [520: ORI   $rb, str_to_int # $rb stores jump address that would cause autogen]
	0191 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	0192 : 2040;    --   [0b 0010 0000 0100 0000] -> [asm: (R2):  AND 	$at, $r0]
	0193 : 66c0;    --   [0b 0110 0110 1100 0000] -> [asm:  (I):  ORI 	$t1, 0x0]
	0194 : 72ca;    --   [0b 0111 0010 1100 1010] -> [asm:  (I):  SLLI 	$t1, 0xa]
	0195 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	0196 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	0197 : 66cd;    --   [0b 0110 0110 1100 1101] -> [asm:  (I):  ORI 	$t1, 0xd]
	0198 : 72c6;    --   [0b 0111 0010 1100 0110] -> [asm:  (I):  SLLI 	$t1, 0x6]
	0199 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	019a : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	019b : 66e0;    --   [0b 0110 0110 1110 0000] -> [asm:  (I):  ORI 	$t1, 0x20]
	019c : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	019d : 2544;    --   [0b 0010 0101 0100 0100] -> [asm: (R2):  OR 	$rb, $at]

	019e : 6040;    --   [0b 0110 0000 0100 0000] -> [521: ANDI  $at, 0]
	019f : 2468;    --   [0b 0010 0100 0110 1000] -> [522: OR    $at, $t0]
	01a0 : c790;    --   [0b 1100 0111 1001 0000] -> [523: LB    $rd, $at, 0]
	01a1 : 6040;    --   [0b 0110 0000 0100 0000] -> [524: ANDI  $at, 0]
	01a2 : 646d;    --   [0b 0110 0100 0110 1101] -> [525: ORI   $at, '-']
	01a3 : b4f3;    --   [0b 1011 0100 1111 0011] -> [526: BNE   $at, $rd, 3   # go to str_to_int after check negative FSM]
	01a4 : 6601;    --   [0b 0110 0110 0000 0001] -> [527: ORI   $s0, 1]
	01a5 : 4282;    --   [0b 0100 0010 1000 0010] -> [528: ADDI  $t0, 2        # prepare for next char reading]
	01a6 : a940;    --   [0b 1010 1001 0100 0000] -> [529: JR    $rb]
                    --   label: 01a7 <- [532: mul_10_plus:        # $rc = (($rc << 3) + ($rc << 1)) + $rd]
	01a7 : 6040;    --   [0b 0110 0000 0100 0000] -> [533: ANDI  $at, 0]
	01a8 : 2458;    --   [0b 0010 0100 0101 1000] -> [534: OR    $at, $rc]
	01a9 : 7041;    --   [0b 0111 0000 0100 0001] -> [535: SLLI  $at, 1        # $at is $rc << 1]
	01aa : 01c4;    --   [0b 0000 0001 1100 0100] -> [536: ADD   $rd, $at]
	01ab : 7042;    --   [0b 0111 0000 0100 0010] -> [537: SLLI  $at, 2        # $at is $rc << 3]
	01ac : 01c4;    --   [0b 0000 0001 1100 0100] -> [538: ADD   $rd, $at]
	01ad : 6180;    --   [0b 0110 0001 1000 0000] -> [539: ANDI  $rc, 0]
	01ae : 259c;    --   [0b 0010 0101 1001 1100] -> [540: OR    $rc, $rd      # copy result to $rc]
	01af : a940;    --   [0b 1010 1001 0100 0000] -> [541: JR    $rb]
                    --   label: 01b0 <- [544: str_to_int:]
	01b0 : 6040;    --   [0b 0110 0000 0100 0000] -> [545: ANDI  $at, 0]
	01b1 : 2468;    --   [0b 0010 0100 0110 1000] -> [546: OR    $at, $t0        # load byte char from memory at $t0]
	01b2 : 61c0;    --   [0b 0110 0001 1100 0000] -> [547: ANDI  $rd, 0]
	01b3 : c790;    --   [0b 1100 0111 1001 0000] -> [548: LB    $rd, $at, 0     # $rd = $($t0 + 0) for one byte]
	01b4 : 6240;    --   [0b 0110 0010 0100 0000] -> [549: ANDI  $s1, 0]
                    --   auto-gen (0x39a > 5bits) <- [550: ORI   $s1, generate_int # $s1 stores jump address that would cause autogen]
	01b5 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	01b6 : 2040;    --   [0b 0010 0000 0100 0000] -> [asm: (R2):  AND 	$at, $r0]
	01b7 : 66c0;    --   [0b 0110 0110 1100 0000] -> [asm:  (I):  ORI 	$t1, 0x0]
	01b8 : 72ca;    --   [0b 0111 0010 1100 1010] -> [asm:  (I):  SLLI 	$t1, 0xa]
	01b9 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	01ba : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	01bb : 66ce;    --   [0b 0110 0110 1100 1110] -> [asm:  (I):  ORI 	$t1, 0xe]
	01bc : 72c6;    --   [0b 0111 0010 1100 0110] -> [asm:  (I):  SLLI 	$t1, 0x6]
	01bd : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	01be : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	01bf : 66da;    --   [0b 0110 0110 1101 1010] -> [asm:  (I):  ORI 	$t1, 0x1a]
	01c0 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	01c1 : 2644;    --   [0b 0010 0110 0100 0100] -> [asm: (R2):  OR 	$s1, $at]

	01c2 : 6040;    --   [0b 0110 0000 0100 0000] -> [551: ANDI  $at, 0]
	01c3 : 6440;    --   [0b 0110 0100 0100 0000] -> [552: ORI   $at, 0          # 0 is null char]
	01c4 : b4f2;    --   [0b 1011 0100 1111 0010] -> [553: BNE   $at, $rd, 2     # check if char $rd is null character]
	01c5 : aa40;    --   [0b 1010 1010 0100 0000] -> [554: JR    $s1]
	01c6 : 6040;    --   [0b 0110 0000 0100 0000] -> [556: ANDI  $at, 0]
	01c7 : 644a;    --   [0b 0110 0100 0100 1010] -> [557: ORI   $at, 10         # ascii code for newline '\n']
	01c8 : b4f2;    --   [0b 1011 0100 1111 0010] -> [559: BNE   $at, $rd, 2     # check if char $rd is new line ]
	01c9 : aa40;    --   [0b 1010 1010 0100 0000] -> [560: JR    $s1]
	01ca : 4282;    --   [0b 0100 0010 1000 0010] -> [562: ADDI  $t0, 2          # prepare for reading next char]
	01cb : 61cf;    --   [0b 0110 0001 1100 1111] -> [563: ANDI  $rd, 0x000f     # convert number char to number]
	01cc : a34e;    --   [0b 1010 0011 0100 1110] -> [564: J     mul_10_plus     # $rc = 10 * $rc + $rd]
                    --   label: 01cd <- [566: generate_int:]
	01cd : 6280;    --   [0b 0110 0010 1000 0000] -> [567: ANDI  $t0, 0]
                    --   auto-gen (0x3da > 5bits) <- [568: ORI   $t0, move_to_t0 # $t0 stores jump address that would cause autogen]
	01ce : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	01cf : 2040;    --   [0b 0010 0000 0100 0000] -> [asm: (R2):  AND 	$at, $r0]
	01d0 : 66c0;    --   [0b 0110 0110 1100 0000] -> [asm:  (I):  ORI 	$t1, 0x0]
	01d1 : 72ca;    --   [0b 0111 0010 1100 1010] -> [asm:  (I):  SLLI 	$t1, 0xa]
	01d2 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	01d3 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	01d4 : 66cf;    --   [0b 0110 0110 1100 1111] -> [asm:  (I):  ORI 	$t1, 0xf]
	01d5 : 72c6;    --   [0b 0111 0010 1100 0110] -> [asm:  (I):  SLLI 	$t1, 0x6]
	01d6 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	01d7 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	01d8 : 66da;    --   [0b 0110 0110 1101 1010] -> [asm:  (I):  ORI 	$t1, 0x1a]
	01d9 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	01da : 2684;    --   [0b 0010 0110 1000 0100] -> [asm: (R2):  OR 	$t0, $at]

	01db : 6040;    --   [0b 0110 0000 0100 0000] -> [569: ANDI  $at, 0]
	01dc : 2460;    --   [0b 0010 0100 0110 0000] -> [570: OR    $at, $s0]
	01dd : b482;    --   [0b 1011 0100 1000 0010] -> [571: BNE   $at, $r0, 2     # need to handle negative if s0 is not zero]
	01de : aa80;    --   [0b 1010 1010 1000 0000] -> [572: JR    $t0     ]
                    --   auto-gen (0xffff > 5bits) <- [574: XORI  $rc, 0xffff]
	01df : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	01e0 : 2040;    --   [0b 0010 0000 0100 0000] -> [asm: (R2):  AND 	$at, $r0]
	01e1 : 66ff;    --   [0b 0110 0110 1111 1111] -> [asm:  (I):  ORI 	$t1, 0x3f]
	01e2 : 72ca;    --   [0b 0111 0010 1100 1010] -> [asm:  (I):  SLLI 	$t1, 0xa]
	01e3 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	01e4 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	01e5 : 66cf;    --   [0b 0110 0110 1100 1111] -> [asm:  (I):  ORI 	$t1, 0xf]
	01e6 : 72c6;    --   [0b 0111 0010 1100 0110] -> [asm:  (I):  SLLI 	$t1, 0x6]
	01e7 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	01e8 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	01e9 : 66ff;    --   [0b 0110 0110 1111 1111] -> [asm:  (I):  ORI 	$t1, 0x3f]
	01ea : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	01eb : 2984;    --   [0b 0010 1001 1000 0100] -> [asm: (R2):  XOR 	$rc, $at]

	01ec : 4181;    --   [0b 0100 0001 1000 0001] -> [575: ADDI  $rc, 1          # negate. -$rc = ~$rc + 1]
                    --   label: 01ed <- [577: move_to_t0:]
	01ed : 6280;    --   [0b 0110 0010 1000 0000] -> [578: ANDI  $t0, 0]
	01ee : 2698;    --   [0b 0010 0110 1001 1000] -> [579: OR    $t0, $rc]
	01ef : c0a0;    --   [0b 1100 0000 1010 0000] -> [581: LW    $at, $sp, 0   ]
	01f0 : 6200;    --   [0b 0110 0010 0000 0000] -> [582: ANDI  $s0, 0]
	01f1 : 2604;    --   [0b 0010 0110 0000 0100] -> [583: OR    $s0, $at      # restore $s1]
	01f2 : c221;    --   [0b 1100 0010 0010 0001] -> [584: LW    $ra, $sp, 1   # restore $ra ]
	01f3 : 4084;    --   [0b 0100 0000 1000 0100] -> [585: ADDI  $sp, 4        # restore $sp and return]
	01f4 : a900;    --   [0b 1010 1001 0000 0000] -> [586: JR    $ra]
                    --   label: 01f5 <- [602: multiply:]
	01f5 : 40be;    --   [0b 0100 0000 1011 1110] -> [603: ADDI  $sp, -2]
	01f6 : c940;    --   [0b 1100 1001 0100 0000] -> [604: SW    $sp, $ra, 0 ]
	01f7 : 6200;    --   [0b 0110 0010 0000 0000] -> [606: ANDI  $s0, 0        # FSM to check negative seen 0/1/2 times]
	01f8 : 6040;    --   [0b 0110 0000 0100 0000] -> [607: ANDI  $at, 0        # assembler temporary]
	01f9 : 6100;    --   [0b 0110 0001 0000 0000] -> [608: ANDI  $ra, 0]
	01fa : 2528;    --   [0b 0010 0101 0010 1000] -> [609: OR    $ra, $t0      # copy int a for multiplication base]
	01fb : 6280;    --   [0b 0110 0010 1000 0000] -> [610: ANDI  $t0, 0        # collect temporary answer]
                    --   label: 01fc <- [612: check_arg_a:]
	01fc : 6240;    --   [0b 0110 0010 0100 0000] -> [613: ANDI  $s1, 0        # $s1 stores jump address that would cause autogen]
                    --   auto-gen (0x454 > 5bits) <- [614: ORI   $s1, check_arg_b]
	01fd : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	01fe : 2040;    --   [0b 0010 0000 0100 0000] -> [asm: (R2):  AND 	$at, $r0]
	01ff : 66c1;    --   [0b 0110 0110 1100 0001] -> [asm:  (I):  ORI 	$t1, 0x1]
	0200 : 72ca;    --   [0b 0111 0010 1100 1010] -> [asm:  (I):  SLLI 	$t1, 0xa]
	0201 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	0202 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	0203 : 66c1;    --   [0b 0110 0110 1100 0001] -> [asm:  (I):  ORI 	$t1, 0x1]
	0204 : 72c6;    --   [0b 0111 0010 1100 0110] -> [asm:  (I):  SLLI 	$t1, 0x6]
	0205 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	0206 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	0207 : 66d4;    --   [0b 0110 0110 1101 0100] -> [asm:  (I):  ORI 	$t1, 0x14]
	0208 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	0209 : 2644;    --   [0b 0010 0110 0100 0100] -> [asm: (R2):  OR 	$s1, $at]

	020a : 6040;    --   [0b 0110 0000 0100 0000] -> [615: ANDI  $at, 0]
                    --   auto-gen (0x8000 > 5bits) <- [616: ORI   $at, 0x8000   # leftmost bit check bit]
	020b : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	020c : 2040;    --   [0b 0010 0000 0100 0000] -> [asm: (R2):  AND 	$at, $r0]
	020d : 66e0;    --   [0b 0110 0110 1110 0000] -> [asm:  (I):  ORI 	$t1, 0x20]
	020e : 72ca;    --   [0b 0111 0010 1100 1010] -> [asm:  (I):  SLLI 	$t1, 0xa]
	020f : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	0210 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	0211 : 66c0;    --   [0b 0110 0110 1100 0000] -> [asm:  (I):  ORI 	$t1, 0x0]
	0212 : 72c6;    --   [0b 0111 0010 1100 0110] -> [asm:  (I):  SLLI 	$t1, 0x6]
	0213 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	0214 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	0215 : 66c0;    --   [0b 0110 0110 1100 0000] -> [asm:  (I):  ORI 	$t1, 0x0]
	0216 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	0217 : 2444;    --   [0b 0010 0100 0100 0100] -> [asm: (R2):  OR 	$at, $at]

	0218 : 2050;    --   [0b 0010 0000 0101 0000] -> [617: AND   $at, $ra      # mask $ra to check negative sign for a]
	0219 : b482;    --   [0b 1011 0100 1000 0010] -> [618: BNE   $at, $r0, 2   # branch if negative]
	021a : aa40;    --   [0b 1010 1010 0100 0000] -> [619: JR    $s1]
	021b : 4201;    --   [0b 0100 0010 0000 0001] -> [620: ADDI  $s0, 1        # mark as negative (+1)]
                    --   auto-gen (0xffff > 5bits) <- [621: XORI  $ra, 0xffff]
	021c : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	021d : 2040;    --   [0b 0010 0000 0100 0000] -> [asm: (R2):  AND 	$at, $r0]
	021e : 66ff;    --   [0b 0110 0110 1111 1111] -> [asm:  (I):  ORI 	$t1, 0x3f]
	021f : 72ca;    --   [0b 0111 0010 1100 1010] -> [asm:  (I):  SLLI 	$t1, 0xa]
	0220 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	0221 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	0222 : 66cf;    --   [0b 0110 0110 1100 1111] -> [asm:  (I):  ORI 	$t1, 0xf]
	0223 : 72c6;    --   [0b 0111 0010 1100 0110] -> [asm:  (I):  SLLI 	$t1, 0x6]
	0224 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	0225 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	0226 : 66ff;    --   [0b 0110 0110 1111 1111] -> [asm:  (I):  ORI 	$t1, 0x3f]
	0227 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	0228 : 2904;    --   [0b 0010 1001 0000 0100] -> [asm: (R2):  XOR 	$ra, $at]

	0229 : 4101;    --   [0b 0100 0001 0000 0001] -> [622: ADDI  $ra, 1        # negate  a]
                    --   label: 022a <- [624: check_arg_b:]
	022a : 6240;    --   [0b 0110 0010 0100 0000] -> [625: ANDI  $s1, 0        # $s1 stores jump address that would cause autogen]
                    --   auto-gen (0x4b0 > 5bits) <- [626: ORI   $s1, multloop]
	022b : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	022c : 2040;    --   [0b 0010 0000 0100 0000] -> [asm: (R2):  AND 	$at, $r0]
	022d : 66c1;    --   [0b 0110 0110 1100 0001] -> [asm:  (I):  ORI 	$t1, 0x1]
	022e : 72ca;    --   [0b 0111 0010 1100 1010] -> [asm:  (I):  SLLI 	$t1, 0xa]
	022f : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	0230 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	0231 : 66c2;    --   [0b 0110 0110 1100 0010] -> [asm:  (I):  ORI 	$t1, 0x2]
	0232 : 72c6;    --   [0b 0111 0010 1100 0110] -> [asm:  (I):  SLLI 	$t1, 0x6]
	0233 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	0234 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	0235 : 66f0;    --   [0b 0110 0110 1111 0000] -> [asm:  (I):  ORI 	$t1, 0x30]
	0236 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	0237 : 2644;    --   [0b 0010 0110 0100 0100] -> [asm: (R2):  OR 	$s1, $at]

	0238 : 6040;    --   [0b 0110 0000 0100 0000] -> [627: ANDI  $at, 0        # reset to check negative sign for b]
                    --   auto-gen (0x8000 > 5bits) <- [628: ORI   $at, 0x8000]
	0239 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	023a : 2040;    --   [0b 0010 0000 0100 0000] -> [asm: (R2):  AND 	$at, $r0]
	023b : 66e0;    --   [0b 0110 0110 1110 0000] -> [asm:  (I):  ORI 	$t1, 0x20]
	023c : 72ca;    --   [0b 0111 0010 1100 1010] -> [asm:  (I):  SLLI 	$t1, 0xa]
	023d : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	023e : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	023f : 66c0;    --   [0b 0110 0110 1100 0000] -> [asm:  (I):  ORI 	$t1, 0x0]
	0240 : 72c6;    --   [0b 0111 0010 1100 0110] -> [asm:  (I):  SLLI 	$t1, 0x6]
	0241 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	0242 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	0243 : 66c0;    --   [0b 0110 0110 1100 0000] -> [asm:  (I):  ORI 	$t1, 0x0]
	0244 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	0245 : 2444;    --   [0b 0010 0100 0100 0100] -> [asm: (R2):  OR 	$at, $at]

	0246 : 2054;    --   [0b 0010 0000 0101 0100] -> [629: AND   $at, $rb      # mask $rb to check negative sign for b]
	0247 : b482;    --   [0b 1011 0100 1000 0010] -> [630: BNE   $at, $r0, 2]
	0248 : aa40;    --   [0b 1010 1010 0100 0000] -> [631: JR    $s1]
	0249 : 4201;    --   [0b 0100 0010 0000 0001] -> [632: ADDI  $s0, 1        # mark as negative ($s0 is now 1 or 2)]
                    --   auto-gen (0xffff > 5bits) <- [633: XORI  $rb, 0xffff]
	024a : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	024b : 2040;    --   [0b 0010 0000 0100 0000] -> [asm: (R2):  AND 	$at, $r0]
	024c : 66ff;    --   [0b 0110 0110 1111 1111] -> [asm:  (I):  ORI 	$t1, 0x3f]
	024d : 72ca;    --   [0b 0111 0010 1100 1010] -> [asm:  (I):  SLLI 	$t1, 0xa]
	024e : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	024f : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	0250 : 66cf;    --   [0b 0110 0110 1100 1111] -> [asm:  (I):  ORI 	$t1, 0xf]
	0251 : 72c6;    --   [0b 0111 0010 1100 0110] -> [asm:  (I):  SLLI 	$t1, 0x6]
	0252 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	0253 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	0254 : 66ff;    --   [0b 0110 0110 1111 1111] -> [asm:  (I):  ORI 	$t1, 0x3f]
	0255 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	0256 : 2944;    --   [0b 0010 1001 0100 0100] -> [asm: (R2):  XOR 	$rb, $at]

	0257 : 4141;    --   [0b 0100 0001 0100 0001] -> [634: ADDI  $rb, 1]
                    --   label: 0258 <- [636: multloop:           # $t0 keeps track of potential result]
	0258 : 62c0;    --   [0b 0110 0010 1100 0000] -> [637: ANDI  $t1, 0        # $t1 stores jump address that would cause autogen]
                    --   auto-gen (0x4d6 > 5bits) <- [638: ORI   $t1, handle_negative]
	0259 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	025a : 2040;    --   [0b 0010 0000 0100 0000] -> [asm: (R2):  AND 	$at, $r0]
	025b : 66c1;    --   [0b 0110 0110 1100 0001] -> [asm:  (I):  ORI 	$t1, 0x1]
	025c : 72ca;    --   [0b 0111 0010 1100 1010] -> [asm:  (I):  SLLI 	$t1, 0xa]
	025d : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	025e : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	025f : 66c3;    --   [0b 0110 0110 1100 0011] -> [asm:  (I):  ORI 	$t1, 0x3]
	0260 : 72c6;    --   [0b 0111 0010 1100 0110] -> [asm:  (I):  SLLI 	$t1, 0x6]
	0261 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	0262 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	0263 : 66d6;    --   [0b 0110 0110 1101 0110] -> [asm:  (I):  ORI 	$t1, 0x16]
	0264 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	0265 : 26c4;    --   [0b 0010 0110 1100 0100] -> [asm: (R2):  OR 	$t1, $at]

	0266 : b682;    --   [0b 1011 0110 1000 0010] -> [639: BNE   $rb, $r0, 2   # exit loop if $rb is zero]
	0267 : aac0;    --   [0b 1010 1010 1100 0000] -> [640: JR    $t1           # $t1 is handle_negative]
	0268 : 0290;    --   [0b 0000 0010 1001 0000] -> [641: ADD   $t0, $ra]
	0269 : 417f;    --   [0b 0100 0001 0111 1111] -> [642: ADDI  $rb, -1]
	026a : aa40;    --   [0b 1010 1010 0100 0000] -> [643: JR    $s1           # $s1 is multloop]
                    --   label: 026b <- [645: handle_negative:]
	026b : 61c0;    --   [0b 0110 0001 1100 0000] -> [646: ANDI  $rd, 0        # test if $s0 is 1 (0 or 2 means result is positive)]
	026c : 25e0;    --   [0b 0010 0101 1110 0000] -> [647: OR    $rd, $s0]
	026d : 6180;    --   [0b 0110 0001 1000 0000] -> [648: ANDI  $rc, 0]
	026e : 4181;    --   [0b 0100 0001 1000 0001] -> [649: ADDI  $rc, 1]
	026f : 6240;    --   [0b 0110 0010 0100 0000] -> [651: ANDI  $s1, 0        # $s1 store address > 0x3ff that cause autogen for Jump]
                    --   auto-gen (0x51a > 5bits) <- [652: ORI   $s1, mult_end ]
	0270 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	0271 : 2040;    --   [0b 0010 0000 0100 0000] -> [asm: (R2):  AND 	$at, $r0]
	0272 : 66c1;    --   [0b 0110 0110 1100 0001] -> [asm:  (I):  ORI 	$t1, 0x1]
	0273 : 72ca;    --   [0b 0111 0010 1100 1010] -> [asm:  (I):  SLLI 	$t1, 0xa]
	0274 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	0275 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	0276 : 66c4;    --   [0b 0110 0110 1100 0100] -> [asm:  (I):  ORI 	$t1, 0x4]
	0277 : 72c6;    --   [0b 0111 0010 1100 0110] -> [asm:  (I):  SLLI 	$t1, 0x6]
	0278 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	0279 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	027a : 66da;    --   [0b 0110 0110 1101 1010] -> [asm:  (I):  ORI 	$t1, 0x1a]
	027b : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	027c : 2644;    --   [0b 0010 0110 0100 0100] -> [asm: (R2):  OR 	$s1, $at]

	027d : b372;    --   [0b 1011 0011 0111 0010] -> [653: BEQ   $rc, $rd, 2   # branch if negative sign is 1]
	027e : aa40;    --   [0b 1010 1010 0100 0000] -> [654: JR    $s1]
                    --   auto-gen (0xffff > 5bits) <- [655: XORI  $t0, 0xffff]
	027f : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	0280 : 2040;    --   [0b 0010 0000 0100 0000] -> [asm: (R2):  AND 	$at, $r0]
	0281 : 66ff;    --   [0b 0110 0110 1111 1111] -> [asm:  (I):  ORI 	$t1, 0x3f]
	0282 : 72ca;    --   [0b 0111 0010 1100 1010] -> [asm:  (I):  SLLI 	$t1, 0xa]
	0283 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	0284 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	0285 : 66cf;    --   [0b 0110 0110 1100 1111] -> [asm:  (I):  ORI 	$t1, 0xf]
	0286 : 72c6;    --   [0b 0111 0010 1100 0110] -> [asm:  (I):  SLLI 	$t1, 0x6]
	0287 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	0288 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	0289 : 66ff;    --   [0b 0110 0110 1111 1111] -> [asm:  (I):  ORI 	$t1, 0x3f]
	028a : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	028b : 2a84;    --   [0b 0010 1010 1000 0100] -> [asm: (R2):  XOR 	$t0, $at]

	028c : 4281;    --   [0b 0100 0010 1000 0001] -> [656: ADDI  $t0, 1        # negate $at]
                    --   label: 028d <- [658: mult_end:]
	028d : c220;    --   [0b 1100 0010 0010 0000] -> [659: LW    $ra, $sp, 0   # restore $ra and return]
	028e : 4082;    --   [0b 0100 0000 1000 0010] -> [660: ADDI  $sp, 2]
	028f : a900;    --   [0b 1010 1001 0000 0000] -> [661: JR    $ra]
                    --   label: 0290 <- [674: multiply_service:]
	0290 : 40be;    --   [0b 0100 0000 1011 1110] -> [675: ADDI  $sp, -2]
	0291 : c940;    --   [0b 1100 1001 0100 0000] -> [676: SW    $sp, $ra, 0 ]
	0292 : 6280;    --   [0b 0110 0010 1000 0000] -> [678: ANDI  $t0, 0]
                    --   auto-gen (0xe000 > 5bits) <- [679: ORI   $t0, CONST_prompt1  # prompt to input first number]
	0293 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	0294 : 2040;    --   [0b 0010 0000 0100 0000] -> [asm: (R2):  AND 	$at, $r0]
	0295 : 66f8;    --   [0b 0110 0110 1111 1000] -> [asm:  (I):  ORI 	$t1, 0x38]
	0296 : 72ca;    --   [0b 0111 0010 1100 1010] -> [asm:  (I):  SLLI 	$t1, 0xa]
	0297 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	0298 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	0299 : 66c0;    --   [0b 0110 0110 1100 0000] -> [asm:  (I):  ORI 	$t1, 0x0]
	029a : 72c6;    --   [0b 0111 0010 1100 0110] -> [asm:  (I):  SLLI 	$t1, 0x6]
	029b : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	029c : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	029d : 66c0;    --   [0b 0110 0110 1100 0000] -> [asm:  (I):  ORI 	$t1, 0x0]
	029e : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	029f : 2684;    --   [0b 0010 0110 1000 0100] -> [asm: (R2):  OR 	$t0, $at]

	02a0 : a51e;    --   [0b 1010 0101 0001 1110] -> [680: JAL   putString]
	02a1 : 6280;    --   [0b 0110 0010 1000 0000] -> [682: ANDI  $t0, 0]
                    --   auto-gen (0xe024 > 5bits) <- [683: ORI   $t0, CHAR_mem       # string buffer for multiplicand]
	02a2 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	02a3 : 2040;    --   [0b 0010 0000 0100 0000] -> [asm: (R2):  AND 	$at, $r0]
	02a4 : 66f8;    --   [0b 0110 0110 1111 1000] -> [asm:  (I):  ORI 	$t1, 0x38]
	02a5 : 72ca;    --   [0b 0111 0010 1100 1010] -> [asm:  (I):  SLLI 	$t1, 0xa]
	02a6 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	02a7 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	02a8 : 66c0;    --   [0b 0110 0110 1100 0000] -> [asm:  (I):  ORI 	$t1, 0x0]
	02a9 : 72c6;    --   [0b 0111 0010 1100 0110] -> [asm:  (I):  SLLI 	$t1, 0x6]
	02aa : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	02ab : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	02ac : 66e4;    --   [0b 0110 0110 1110 0100] -> [asm:  (I):  ORI 	$t1, 0x24]
	02ad : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	02ae : 2684;    --   [0b 0010 0110 1000 0100] -> [asm: (R2):  OR 	$t0, $at]

	02af : a550;    --   [0b 1010 0101 0101 0000] -> [684: JAL   getString]
	02b0 : 6280;    --   [0b 0110 0010 1000 0000] -> [685: ANDI  $t0, 0]
                    --   auto-gen (0xe024 > 5bits) <- [686: ORI   $t0, CHAR_mem]
	02b1 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	02b2 : 2040;    --   [0b 0010 0000 0100 0000] -> [asm: (R2):  AND 	$at, $r0]
	02b3 : 66f8;    --   [0b 0110 0110 1111 1000] -> [asm:  (I):  ORI 	$t1, 0x38]
	02b4 : 72ca;    --   [0b 0111 0010 1100 1010] -> [asm:  (I):  SLLI 	$t1, 0xa]
	02b5 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	02b6 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	02b7 : 66c0;    --   [0b 0110 0110 1100 0000] -> [asm:  (I):  ORI 	$t1, 0x0]
	02b8 : 72c6;    --   [0b 0111 0010 1100 0110] -> [asm:  (I):  SLLI 	$t1, 0x6]
	02b9 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	02ba : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	02bb : 66e4;    --   [0b 0110 0110 1110 0100] -> [asm:  (I):  ORI 	$t1, 0x24]
	02bc : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	02bd : 2684;    --   [0b 0010 0110 1000 0100] -> [asm: (R2):  OR 	$t0, $at]

	02be : a710;    --   [0b 1010 0111 0001 0000] -> [687: JAL   stringToInt]
	02bf : 6200;    --   [0b 0110 0010 0000 0000] -> [689: ANDI  $s0, 0              # save for multiply]
	02c0 : 2628;    --   [0b 0010 0110 0010 1000] -> [690: OR    $s0, $t0]
	02c1 : 6280;    --   [0b 0110 0010 1000 0000] -> [691: ANDI  $t0, 0]
                    --   auto-gen (0xe00c > 5bits) <- [692: ORI   $t0, CONST_prompt2  # prompt to input second number]
	02c2 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	02c3 : 2040;    --   [0b 0010 0000 0100 0000] -> [asm: (R2):  AND 	$at, $r0]
	02c4 : 66f8;    --   [0b 0110 0110 1111 1000] -> [asm:  (I):  ORI 	$t1, 0x38]
	02c5 : 72ca;    --   [0b 0111 0010 1100 1010] -> [asm:  (I):  SLLI 	$t1, 0xa]
	02c6 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	02c7 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	02c8 : 66c0;    --   [0b 0110 0110 1100 0000] -> [asm:  (I):  ORI 	$t1, 0x0]
	02c9 : 72c6;    --   [0b 0111 0010 1100 0110] -> [asm:  (I):  SLLI 	$t1, 0x6]
	02ca : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	02cb : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	02cc : 66cc;    --   [0b 0110 0110 1100 1100] -> [asm:  (I):  ORI 	$t1, 0xc]
	02cd : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	02ce : 2684;    --   [0b 0010 0110 1000 0100] -> [asm: (R2):  OR 	$t0, $at]

	02cf : a51e;    --   [0b 1010 0101 0001 1110] -> [693: JAL   putString]
	02d0 : 6280;    --   [0b 0110 0010 1000 0000] -> [695: ANDI  $t0, 0]
                    --   auto-gen (0xe024 > 5bits) <- [696: ORI   $t0, CHAR_mem       # string buffer for multiplier]
	02d1 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	02d2 : 2040;    --   [0b 0010 0000 0100 0000] -> [asm: (R2):  AND 	$at, $r0]
	02d3 : 66f8;    --   [0b 0110 0110 1111 1000] -> [asm:  (I):  ORI 	$t1, 0x38]
	02d4 : 72ca;    --   [0b 0111 0010 1100 1010] -> [asm:  (I):  SLLI 	$t1, 0xa]
	02d5 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	02d6 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	02d7 : 66c0;    --   [0b 0110 0110 1100 0000] -> [asm:  (I):  ORI 	$t1, 0x0]
	02d8 : 72c6;    --   [0b 0111 0010 1100 0110] -> [asm:  (I):  SLLI 	$t1, 0x6]
	02d9 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	02da : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	02db : 66e4;    --   [0b 0110 0110 1110 0100] -> [asm:  (I):  ORI 	$t1, 0x24]
	02dc : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	02dd : 2684;    --   [0b 0010 0110 1000 0100] -> [asm: (R2):  OR 	$t0, $at]

	02de : a550;    --   [0b 1010 0101 0101 0000] -> [697: JAL   getString]
	02df : 6280;    --   [0b 0110 0010 1000 0000] -> [698: ANDI  $t0, 0]
                    --   auto-gen (0xe024 > 5bits) <- [699: ORI   $t0, CHAR_mem]
	02e0 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	02e1 : 2040;    --   [0b 0010 0000 0100 0000] -> [asm: (R2):  AND 	$at, $r0]
	02e2 : 66f8;    --   [0b 0110 0110 1111 1000] -> [asm:  (I):  ORI 	$t1, 0x38]
	02e3 : 72ca;    --   [0b 0111 0010 1100 1010] -> [asm:  (I):  SLLI 	$t1, 0xa]
	02e4 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	02e5 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	02e6 : 66c0;    --   [0b 0110 0110 1100 0000] -> [asm:  (I):  ORI 	$t1, 0x0]
	02e7 : 72c6;    --   [0b 0111 0010 1100 0110] -> [asm:  (I):  SLLI 	$t1, 0x6]
	02e8 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	02e9 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	02ea : 66e4;    --   [0b 0110 0110 1110 0100] -> [asm:  (I):  ORI 	$t1, 0x24]
	02eb : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	02ec : 2684;    --   [0b 0010 0110 1000 0100] -> [asm: (R2):  OR 	$t0, $at]

	02ed : a710;    --   [0b 1010 0111 0001 0000] -> [700: JAL   stringToInt]
	02ee : 6140;    --   [0b 0110 0001 0100 0000] -> [702: ANDI  $rb, 0]
	02ef : 2560;    --   [0b 0010 0101 0110 0000] -> [703: OR    $rb, $s0            # set multiplier to $rb]
	02f0 : a7ea;    --   [0b 1010 0111 1110 1010] -> [704: JAL   multiply            # multiplicand is already set at $t0 ]
	02f1 : 6200;    --   [0b 0110 0010 0000 0000] -> [706: ANDI  $s0, 0]
	02f2 : 2628;    --   [0b 0010 0110 0010 1000] -> [707: OR    $s0, $t0            # save answer]
	02f3 : 6280;    --   [0b 0110 0010 1000 0000] -> [708: ANDI  $t0, 0]
                    --   auto-gen (0xe018 > 5bits) <- [709: ORI   $t0, CONST_answer]
	02f4 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	02f5 : 2040;    --   [0b 0010 0000 0100 0000] -> [asm: (R2):  AND 	$at, $r0]
	02f6 : 66f8;    --   [0b 0110 0110 1111 1000] -> [asm:  (I):  ORI 	$t1, 0x38]
	02f7 : 72ca;    --   [0b 0111 0010 1100 1010] -> [asm:  (I):  SLLI 	$t1, 0xa]
	02f8 : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	02f9 : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	02fa : 66c0;    --   [0b 0110 0110 1100 0000] -> [asm:  (I):  ORI 	$t1, 0x0]
	02fb : 72c6;    --   [0b 0111 0010 1100 0110] -> [asm:  (I):  SLLI 	$t1, 0x6]
	02fc : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	02fd : 22c0;    --   [0b 0010 0010 1100 0000] -> [asm: (R2):  AND 	$t1, $r0]
	02fe : 66d8;    --   [0b 0110 0110 1101 1000] -> [asm:  (I):  ORI 	$t1, 0x18]
	02ff : 246c;    --   [0b 0010 0100 0110 1100] -> [asm: (R2):  OR 	$at, $t1]
	0300 : 2684;    --   [0b 0010 0110 1000 0100] -> [asm: (R2):  OR 	$t0, $at]

	0301 : a51e;    --   [0b 1010 0101 0001 1110] -> [710: JAL   putString]
	0302 : 6280;    --   [0b 0110 0010 1000 0000] -> [711: ANDI  $t0, 0]
	0303 : 26a0;    --   [0b 0010 0110 1010 0000] -> [712: OR    $t0, $s0]
	0304 : a5cc;    --   [0b 1010 0101 1100 1100] -> [713: JAL   intToString         # output answer as string]
	0305 : 6280;    --   [0b 0110 0010 1000 0000] -> [715: ANDI  $t0, 0]
	0306 : 668a;    --   [0b 0110 0110 1000 1010] -> [716: ORI   $t0, 10             # add '\n']
	0307 : a454;    --   [0b 1010 0100 0101 0100] -> [717: JAL   putchar]
	0308 : c220;    --   [0b 1100 0010 0010 0000] -> [719: LW    $ra, $sp, 0         # restore $ra and return]
	0309 : 4082;    --   [0b 0100 0000 1000 0010] -> [720: ADDI  $sp, 2]
	030a : a900;    --   [0b 1010 1001 0000 0000] -> [721: JR    $ra]
                    --   label: 030b <- [725: PROGRAM_END:]
END;
